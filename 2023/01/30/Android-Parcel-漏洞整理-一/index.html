<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="cn">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="android,parcel,bundle mismatch,framework,">










<meta name="description" content="Brief在Android系统中Parcel对象是一个非常常用的进程间消息传递的载体。由于该结构原本并没有一些内容的完整性校验，这导致了发送者所发送的数据与接收者所接受的数据可能并不相同。从这一漏洞点出发，攻击者不断开发出了如self-changing Bundle等多种利用方案； 在去年的BlackHat EU中，Google 宣布在Android 13中引入了全新安全的Parcel机制。针对P">
<meta name="keywords" content="android,parcel,bundle mismatch,framework">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Parcel 系列系列漏洞整理 (一)">
<meta property="og:url" content="http://N1rv0us@github.io/2023/01/30/Android-Parcel-漏洞整理-一/index.html">
<meta property="og:site_name" content="失眠想睡觉的blog">
<meta property="og:description" content="Brief在Android系统中Parcel对象是一个非常常用的进程间消息传递的载体。由于该结构原本并没有一些内容的完整性校验，这导致了发送者所发送的数据与接收者所接受的数据可能并不相同。从这一漏洞点出发，攻击者不断开发出了如self-changing Bundle等多种利用方案； 在去年的BlackHat EU中，Google 宣布在Android 13中引入了全新安全的Parcel机制。针对P">
<meta property="og:locale" content="cn">
<meta property="og:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-4.png">
<meta property="og:updated_time" content="2023-02-28T18:44:44.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android Parcel 系列系列漏洞整理 (一)">
<meta name="twitter:description" content="Brief在Android系统中Parcel对象是一个非常常用的进程间消息传递的载体。由于该结构原本并没有一些内容的完整性校验，这导致了发送者所发送的数据与接收者所接受的数据可能并不相同。从这一漏洞点出发，攻击者不断开发出了如self-changing Bundle等多种利用方案； 在去年的BlackHat EU中，Google 宣布在Android 13中引入了全新安全的Parcel机制。针对P">
<meta name="twitter:image" content="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://N1rv0us@github.io/2023/01/30/Android-Parcel-漏洞整理-一/">





  <title>Android Parcel 系列系列漏洞整理 (一) | 失眠想睡觉的blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">失眠想睡觉的blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://N1rv0us@github.io/2023/01/30/Android-Parcel-漏洞整理-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="N1rv0us">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="失眠想睡觉的blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android Parcel 系列系列漏洞整理 (一)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-01-30T00:00:00+08:00">
                2023-01-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Brief"><a href="#Brief" class="headerlink" title="Brief"></a>Brief</h2><p>在Android系统中Parcel对象是一个非常常用的进程间消息传递的载体。由于该结构原本并没有一些内容的完整性校验，这导致了发送者所发送的数据与接收者所接受的数据可能并不相同。从这一漏洞点出发，攻击者不断开发出了如self-changing Bundle等多种利用方案；</p>
<p>在去年的BlackHat EU中，Google 宣布在Android 13中引入了全新安全的Parcel机制。针对Parcel传输数据中存在的问题作出了改进，封堵了大部分对Parcel Mismatch利用的场景；</p>
<p>笔者从2022年初才开始关注Parcel Mismatch的问题，但是由于拖延症直到最近<code>michalbednarski</code> 爆出在Android 13上的<code>LazyValue</code> 才正式开始梳理相关的漏洞原理，利用场景以及Google的修复方案。主要整合了michalbednarski在其Github上公布的PoC以及BlackHat EU上的slide，希望能对相关漏洞的挖掘有些启示。(如果想深入研究建议还是要看一下相关的代码以及PoC)</p>
<p>为方便观看，整个Parcel Mismatch的问题将被分为三个部分：</p>
<ul>
<li><p>第一部分(本篇) : 介绍Bundle Mismatch的原理，利用以及Android 13中的修复方案</p>
</li>
<li><p>第二部分：介绍ReparcelBug 2的利用链以及在Android 13的修复方案部分</p>
</li>
<li><p>第三部分： 介绍LazyValue的漏洞原理以及利用方式，并总结下未来Parcel Mismatch漏洞的生存问题；</p>
</li>
</ul>
<h2 id="关于Parcel的一些基础知识"><a href="#关于Parcel的一些基础知识" class="headerlink" title="关于Parcel的一些基础知识"></a>关于Parcel的一些基础知识</h2><p><img src="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-1.png" alt="image-1.png"></p>
<p>Parcel可以将Int, String等基础类型以及可序列化的对象(继承自<code>andrid.os.Parcel</code>)打包起来在sender与recevier之间传递。</p>
<p>发送者(sender)通过对象中的<code>writeToParcel</code>方法将对象存入Parcel中，接受者收到Parcel之后，通过<code>createFromParcel</code>中反序列化出对应的原始对象。当Android开发者创建一个可序列化的对象时候，必须要实现其中的<code>writeToParcel</code>方法以及<code>createFromParcel</code>方法。这里就存在一个风险，即通过<code>writeToParcel</code>方法向Parcel中写入的内容与通过<code>createFromParcel</code> 方法读取到的内容可能是不一致的，从而导致接受着(receiver)接受到了完全不一样的内容。在攻击者的巧妙布局下，可以触发许多严重的安全漏洞。</p>
<p>举个例子，在 <a href="https://source.android.com/security/bulletin/2017-10-01#framework" target="_blank" rel="noopener">CVE-2017-0806</a> 的修复patch中，可以看在<code>writeToParcel</code>过程中如果<code>mPayload == null</code>时不会向Parcel中写入内容(包括mPayload.size)，但是<code>createFromParcel</code> 仍然会通过<code>int size = source.readInt()</code>来从Parcel中读取一个size，这就导致了Parcel读写不一致的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GateKeeperResponse <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> responseCode = source.readInt();</span><br><span class="line">    <span class="keyword">final</span> GateKeeperResponse response;</span><br><span class="line">    <span class="keyword">if</span> (responseCode == RESPONSE_RETRY) &#123;</span><br><span class="line">        response = createRetryResponse(source.readInt());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (responseCode == RESPONSE_OK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> shouldReEnroll = source.readInt() == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] payload = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = source.readInt();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            payload = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">            source.readByteArray(payload);</span><br><span class="line">        &#125;</span><br><span class="line">        response = createOkResponse(payload, shouldReEnroll);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response = createGenericResponse(responseCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dest.writeInt(mResponseCode);</span><br><span class="line">    <span class="keyword">if</span> (mResponseCode == RESPONSE_RETRY) &#123;</span><br><span class="line">        dest.writeInt(mTimeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResponseCode == RESPONSE_OK) &#123;</span><br><span class="line">        dest.writeInt(mShouldReEnroll ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mPayload != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dest.writeInt(mPayload.length);</span><br><span class="line">            dest.writeByteArray(mPayload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以自由布局Parcel的另一个关键点是，Parcel对于如List等数据的处理，由于Java Type Erasure机制的存在，攻击者可以向一个可序列化对象的某个参与序列化的List变量中，写入一个与之List声明类型完全不匹配的对象进去，再其反序列化时仍然不受任何影响。在攻击者进行布局时，也可以利用这个特性来一些序列化的对象进去(这段描述可能有些抽象，但是配合下篇文章中的例子一起，就会容易理解一些)。</p>
<p><img src="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-2.png" alt="image-2.png"></p>
<p>到此为止，就完成了对Parcel Mismatch部分的解读，然而让这种不匹配完全转化成一个有价值的安全漏洞就需要配合Android Framework中的一些关键流程，后面会介绍几种常见的套路。更多有价值的利用链有待于安全研究员们继续不断的探索喽。</p>
<h2 id="self-changing-Bundle"><a href="#self-changing-Bundle" class="headerlink" title="self-changing Bundle"></a>self-changing Bundle</h2><p>这是一种非常典型的利用场景，一般攻击者会配合AccountManagerService中一个已经修复过的<a href="https://blogs.360.cn/post/launchanywhere-google-bug-7699048.html" target="_blank" rel="noopener">LaunchAnywhere漏洞</a> </p>
<p><img src="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-3.png" alt="image-3.png"></p>
<p>在这个流程中：</p>
<ul>
<li><p>Attacker APP : 发起AddAccount请求</p>
</li>
<li><p>system_server : 负责检查 <code>KEY_INTENT</code> 中是否包含恶意的信息</p>
</li>
<li><p>Settings APP :  提取Bundle中的<code>KEY_INTENT</code>字段，并执行startActivity</p>
</li>
</ul>
<p>在上面的传递过程中, 利用 Parcel Mismatch 的漏洞，令<code>AccountManagerService</code> 获取到的<code>KEY_INTENT</code>与 <code>Settings APP</code> 获取到的 <code>KEY_INTENT</code> 为不同内容，可以做到利用<code>Settings APP</code> 的LaunchAnywhere.</p>
<p>编写exploit时，需要根据Parcel Mismatch漏洞具体的读写差异调整对Bundle的布局，情况太多以后有机会单独写一篇BLOG整理一下。而在michalbednarski的ReparcelBug项目中整理了Bundle key替换的类 <code>Ambiguator</code> 其中的设计非常的巧妙，仅需少量的修改以及测试就可以完成一个全新的Parcel Mismatch exploit的编写；在heeen的self-changing Bundle的文章中也展示了一些对Bundle布局的思路。</p>
<p>在这里的<code>addAccount</code>流程仅是self-changing Bundle的一个例子，如果尝试以更加抽象一点的语言总结self-changing Bundle的利用应该是这样的：如果在一段代码逻辑中，存在攻击者(Attacker), 对Bundle内容的检查者(Checker)以及实际执行代码者(Executor)；Attacker向Checker发送一个Bundle，Checker检查完Bundle中的内容之后将其序列化后传递给Executor执行；那么Attacker可以利用一些存在Parcel Mismatch来调整Bundle中的布局让Checker与Executor尝试从Bundle中读取某个相同的KEY时，读取到完全不同的内容，进而绕过Checker对于Bundle内容的检查。</p>
<h2 id="Lazy-Bundle-in-Android-13"><a href="#Lazy-Bundle-in-Android-13" class="headerlink" title="Lazy Bundle in Android 13"></a>Lazy Bundle in Android 13</h2><p>为了更加有效的解决self-changing Bundle类型的利用方式，在 Android 13中通过调整了Parcel中数据的布局引入了Lazy Bundle机制，Google的工程师对该功能是这样描述的：</p>
<blockquote>
<p>So, there are basically 3 states:</p>
<ol>
<li>We received the bundle but haven’t queried anything about it (not<br>even isEmpty()): in this case the original parcel is held inside and<br>we haven’t attempted any deserialization (except for the metadata at<br>the beginning such as the magic, etc)</li>
<li>We queried something on it (eg. isEmpty()): Now we deserialize the<br>bundle skipping the custom values above (we’re able to do this now<br>with the length written on the wire) and instead placing LazyValue<br>objects for them in the map.</li>
<li>We query one of the lazy values: Now, we deserialize the object<br>represented by LazyValue and replace it on the map.</li>
</ol>
</blockquote>
<p>从宏观的角度，可以通过下面这张图片来理解：</p>
<p><img src="https://raw.githubusercontent.com/N1rv0us/N1rv0us.github.io/master/2023/01/30/Android-Parcel-%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86-%E4%B8%80/image-4.png" alt="image-4.png"></p>
<p>通过LazyBundle的机制，不再需要将整个Bundle对象反序列化并将内容存入Map中读取，调用<code>bundle.get*()</code>方法可以独立的在Parcel中读取<code>Key-Value</code> 值。这样做一方面可以减少Bundle中某些<code>Key-Value</code>解析异常导致的程序崩溃，另一方面也意味着序列化存入Parcel后的每个<code>Key-Value</code>对都会有独立的存储区域，不会再由于某些对象的解析Mismatch而导致后续解析异常问题(例如前面提到的self-changing Bundle)。</p>
<p>从代码的角度来看，将Bundle中的每个<code>Key-Value</code>对中的Value以LazyValue的形式存入Parcel中，这也是Android 13中引入的一种新的机制，代码中有如下的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                     |   4B   |   4B   |</span><br><span class="line">mSource = Parcel&#123;... |  type  | length | object | ...&#125;</span><br><span class="line">                     a        b        c        d</span><br><span class="line">length = d - c</span><br><span class="line">mPosition = a</span><br><span class="line">mLength = d - a</span><br></pre></td></tr></table></figure>

<p>由于对每个LazyValue对象都有类型和长度的标注，则即使<code>object</code> 部分解析异常，通过对length类型的检查也能够解释的发现，通过抛出异常来阻止一些漏洞的利用。</p>
<p>下面通过代码看下，引入LazyBundle机制之后是如何实现读取内容的(以下的所有代码均可在<a href="https://cs.android.com" target="_blank" rel="noopener">https://cs.android.com</a> 中找到)；</p>
<p>对于从Parcel对象中读取的Bundle对象，会通过<code>BaseBundle.readFromParcelInner</code> 方法进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/BaseBundle.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcelInner</span><span class="params">(Parcel parcel, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> magic = parcel.readInt();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isJavaBundle = magic == BUNDLE_MAGIC;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isNativeBundle = magic == BUNDLE_MAGIC_NATIVE;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Advance within this Parcel</span></span><br><span class="line">    <span class="keyword">int</span> offset = parcel.dataPosition();</span><br><span class="line">    parcel.setDataPosition(MathUtils.addOrThrow(offset, length));</span><br><span class="line">    </span><br><span class="line">    Parcel p = Parcel.obtain();</span><br><span class="line">    p.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    p.appendFrom(parcel, offset, length);</span><br><span class="line">    p.adoptClassCookies(parcel);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"Retrieving "</span>  + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">            + <span class="string">": "</span> + length + <span class="string">" bundle bytes starting at "</span> + offset);</span><br><span class="line">    p.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mParcelledByNative = isNativeBundle;</span><br><span class="line">    mParcelledData = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成JavaBundle/NativeBundle的判定之后，会根据Bundle对象的长度重新设置Parcel对象的position，并将偏移过内容直接拷贝到一个新的Parcel并记录到<code>mParcelledData</code>中，即可完成预读取，在这个过程中不会解析ParcelData。</p>
<p>在有尝试从Bundle中读取数据的操作(<code>get*(String key)</code>)时会触发<code>unparcel</code>方法来解析预先读取到<code>mParcelData</code>中的数据，以getString为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/BaseBundle.java</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(@Nullable String key)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    <span class="keyword">final</span> Object o = mMap.get(key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        typeWarning(key, o, <span class="string">"String"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unparcel</code>会触发一下的解析流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/BaseBundle.java</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unparcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unparcel(<span class="comment">/* itemwise */</span> <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deserializes the underlying data and each item if &#123;<span class="doctag">@code</span> itemwise&#125; is true. */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unparcel</span><span class="params">(<span class="keyword">boolean</span> itemwise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Parcel source = mParcelledData;</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">            initializeFromParcelLocked(source, <span class="comment">/*recycleParcel=*/</span> <span class="keyword">true</span>, mParcelledByNative);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"unparcel "</span></span><br><span class="line">                        + Integer.toHexString(System.identityHashCode(<span class="keyword">this</span>))</span><br><span class="line">                        + <span class="string">": no parcelled data"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeFromParcelLocked</span><span class="params">(@NonNull Parcel parcelledData, <span class="keyword">boolean</span> recycleParcel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> parcelledByNative)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyParcel(parcelledData)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMap = <span class="keyword">new</span> ArrayMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMap.erase();</span><br><span class="line">        &#125;</span><br><span class="line">        mParcelledByNative = <span class="keyword">false</span>;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = parcelledData.readInt();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// recycleParcel being false implies that we do not own the parcel. In this case, do</span></span><br><span class="line">        <span class="comment">// not use lazy values to be safe, as the parcel could be recycled outside of our</span></span><br><span class="line">        <span class="comment">// control.</span></span><br><span class="line">        recycleParcel &amp;= parcelledData.readArrayMap(map, count, !parcelledByNative,</span><br><span class="line">                <span class="comment">/* lazy */</span> recycleParcel, mClassLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BadParcelableException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mMap = map;</span><br><span class="line">        <span class="keyword">if</span> (recycleParcel) &#123;</span><br><span class="line">            recycleParcel(parcelledData);</span><br><span class="line">            mWeakParcelledData = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mWeakParcelledData = <span class="keyword">new</span> WeakReference&lt;&gt;(parcelledData);</span><br><span class="line">        &#125;</span><br><span class="line">        mParcelledByNative = <span class="keyword">false</span>;</span><br><span class="line">        mParcelledData = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unparcel</code>只会实际触发一次解析，通过<code>initializeFromParcelLocked</code>方法来处理，即从 <code>mParcelledData</code>中读取一个长度为<code>count</code>的ArrayMap并将其存入Map中，至此对于<code>mParcelledData</code>的解析完成一半会通过<code>recycleParcel</code>将其回收，对Bundle资源的读取可以直接通过<code>mMap</code>中的key索引即可获取；</p>
<p>但是，由于LazyValue的引入，此时<code>mMap</code>中存储Value值的并非全部都是原始类型的对象，具体看下<code>readArrayMap</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/Parcel.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readArrayMap</span><span class="params">(ArrayMap&lt;? <span class="keyword">super</span> String, Object&gt; map, <span class="keyword">int</span> size, <span class="keyword">boolean</span> sorted,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> lazy, @Nullable ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> recycle = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String key = readString();</span><br><span class="line">        Object value = (lazy) ? readLazyValue(loader) : readValue(loader);</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> LazyValue) &#123;</span><br><span class="line">            recycle = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">            map.append(key, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">        map.validate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recycle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLengthPrefixed</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// In general, we want custom types and containers of custom types to be length-prefixed,</span></span><br><span class="line">    <span class="comment">// this allows clients (eg. Bundle) to skip their content during deserialization. The</span></span><br><span class="line">    <span class="comment">// exception to this is Bundle, since Bundle is already length-prefixed and already copies</span></span><br><span class="line">    <span class="comment">// the correspondent section of the parcel internally.</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> VAL_MAP:</span><br><span class="line">        <span class="keyword">case</span> VAL_PARCELABLE:</span><br><span class="line">        <span class="keyword">case</span> VAL_LIST:</span><br><span class="line">        <span class="keyword">case</span> VAL_SPARSEARRAY:</span><br><span class="line">        <span class="keyword">case</span> VAL_PARCELABLEARRAY:</span><br><span class="line">        <span class="keyword">case</span> VAL_OBJECTARRAY:</span><br><span class="line">        <span class="keyword">case</span> VAL_SERIALIZABLE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">readLazyValue</span><span class="params">(@Nullable ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = dataPosition();</span><br><span class="line">    <span class="keyword">int</span> type = readInt();</span><br><span class="line">    <span class="keyword">if</span> (isLengthPrefixed(type)) &#123;</span><br><span class="line">        <span class="keyword">int</span> objectLength = readInt();</span><br><span class="line">        <span class="keyword">if</span> (objectLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> end = MathUtils.addOrThrow(dataPosition(), objectLength);</span><br><span class="line">        <span class="keyword">int</span> valueLength = end - start;</span><br><span class="line">        setDataPosition(end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyValue(<span class="keyword">this</span>, start, valueLength, type, loader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readValue(type, loader, <span class="comment">/* clazz */</span> <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当readArrayMap方法的lazy被设置为True的时候，会通过<code>readLazyValue</code>方法来读取mMap中的Value，对于支持LazeValue的类型(如MAP, PARCELABLE等)会打包成一个LazyValue对象存入<code>Bundle.mMap</code>中, 这样做是为了减少对于Bundle中某些对象的解析异常导致整个进程崩溃的情况。</p>
<p>当实际触发这些类型的value读取时(以getArrayList为例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/os/BaseBundle.java</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">&lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">getArrayList</span><span class="params">(@Nullable String key, @NonNull Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    unparcel();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getValue(key, ArrayList.class, requireNonNull(clazz));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException | BadTypeParcelableException e) &#123;</span><br><span class="line">        typeWarning(key, <span class="string">"ArrayList&lt;"</span> + clazz.getCanonicalName() + <span class="string">"&gt;"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">getValue</span><span class="params">(String key, @Nullable Class&lt;T&gt; clazz, @Nullable Class&lt;?&gt;... itemTypes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = mMap.indexOfKey(key);</span><br><span class="line">    <span class="keyword">return</span> (i &gt;= <span class="number">0</span>) ? getValueAt(i, clazz, itemTypes) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">getValueAt</span><span class="params">(<span class="keyword">int</span> i, @Nullable Class&lt;T&gt; clazz, @Nullable Class&lt;?&gt;... itemTypes)</span> </span>&#123;</span><br><span class="line">    Object object = mMap.valueAt(i);</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> BiFunction&lt;?, ?, ?&gt;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object = ((BiFunction&lt;Class&lt;?&gt;, Class&lt;?&gt;[], ?&gt;) object).apply(clazz, itemTypes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BadParcelableException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sShouldDefuse) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Failed to parse item "</span> + mMap.keyAt(i) + <span class="string">", returning null."</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.setValueAt(i, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (clazz != <span class="keyword">null</span>) ? clazz.cast(object) : (T) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会触发对应类型的转换完成对LazyValue对象的读取；</p>
<p>至此，对于self-changing Bundle的修复方案的解读完毕，在如此的机制下，是能够有效的防御到self-changing Bundle的利用思路的，至少暂时笔者没想到很好的绕过方案，之后有的话，可能会再开一篇文章来说明的。</p>
<h2 id="Insight"><a href="#Insight" class="headerlink" title="Insight"></a>Insight</h2><p>Android 13 通过引入LazyValue机制虽然可以有效的解决self-changing Bundle的问题，但是个人认为self-changing Bundle仍然是一个很有趣的研究方向，一方面Android 13的普及仍需要一段时间，但是仍会有大量的Mismatch Parcel对象被找出来，这些对象仍然可以被利用来攻击很多的手机系统。另一方面，Android Framework/APP 中必然会有许多符合self-changing Bundle的其他利用场景存在，更多的利用方案配合不同的Bundle布局也会是个很不错的挑战。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://github.com/michalbednarski/IntentsLab/issues/2#issuecomment-344365482" target="_blank" rel="noopener">Could you give me your email address? · Issue #2 · michalbednarski/IntentsLab · GitHub</a></p>
</li>
<li><p><a href="https://github.com/michalbednarski/ReparcelBug2" target="_blank" rel="noopener">GitHub - michalbednarski/ReparcelBug2</a></p>
</li>
<li><p><a href="https://github.com/michalbednarski/LeakValue" target="_blank" rel="noopener">GitHub - michalbednarski/LeakValue: Exploit for CVE-2022-20452, privilege escalation on Android from installed app to system app (or another app) via LazyValue using Parcel after recycle()</a></p>
</li>
<li><p><a href="https://i.blackhat.com/EU-22/Wednesday-Briefings/EU-22-Ke-Android-Parcels-Introducing-Android-Safer-Parcel.pdf" target="_blank" rel="noopener">https://i.blackhat.com/EU-22/Wednesday-Briefings/EU-22-Ke-Android-Parcels-Introducing-Android-Safer-Parcel.pdf</a></p>
</li>
<li><p><a href="https://wrlus.com/android-security/bundle-mismatch/" target="_blank" rel="noopener">https://wrlus.com/android-security/bundle-mismatch/</a></p>
</li>
<li><p><a href="https://xz.aliyun.com/t/2364" target="_blank" rel="noopener">Bundle FengShui</a></p>
</li>
<li><p><a href="https://android.googlesource.com/platform/frameworks/base/+/9ca6a5e21a1987fd3800a899c1384b22d23b6dee%5E%21/" target="_blank" rel="noopener">Introduce to Lazy Bundle</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android/" rel="tag"># android</a>
          
            <a href="/tags/parcel/" rel="tag"># parcel</a>
          
            <a href="/tags/bundle-mismatch/" rel="tag"># bundle mismatch</a>
          
            <a href="/tags/framework/" rel="tag"># framework</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/12/07/DirtyCred-论文笔记/" rel="next" title="DirtyCred 论文阅读笔记">
                <i class="fa fa-chevron-left"></i> DirtyCred 论文阅读笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/02/14/Android-Parcel-漏洞整理-二/" rel="prev" title="Android Parcel Mismatch系列漏洞整理（二）">
                Android Parcel Mismatch系列漏洞整理（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">N1rv0us</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Brief"><span class="nav-number">1.</span> <span class="nav-text">Brief</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Parcel的一些基础知识"><span class="nav-number">2.</span> <span class="nav-text">关于Parcel的一些基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#self-changing-Bundle"><span class="nav-number">3.</span> <span class="nav-text">self-changing Bundle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lazy-Bundle-in-Android-13"><span class="nav-number">4.</span> <span class="nav-text">Lazy Bundle in Android 13</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Insight"><span class="nav-number">5.</span> <span class="nav-text">Insight</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">6.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">N1rv0us</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
